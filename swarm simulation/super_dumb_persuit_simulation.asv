%% Create a multi-robot environment
numRobots = 6;
env = MultiRobotEnv(numRobots);
env.robotRadius = 0.1;
env.showTrajectory = false;

map = binaryOccupancyMap(100,100);
x = 19:22;
y = 19:22;
xy = [p(:) q(:)];
[p,q] = meshgrid(x,y);
setOccupancy(map, xy, ones(4^2,1))
env.mapName = "map";

%% Create robot detectors for all robots
detectors = cell(1,numRobots);
for rIdx = 1:numRobots
    detector = RobotDetector(env,rIdx);
    detector.maxDetections = numRobots;
    detector.maxRange = 15;
    detector.fieldOfView = pi/2;
    detectors{rIdx} = detector;
end
env.plotSensorLines = true; % So the sensor lines don't dominate the visuals

%% Initialization
% Number of robot teams
numTeams = 2;  
env.robotColors = repmat([0 0 1; 1 0 0],[ceil(numRobots/numTeams) 1]);
env.robotColors = env.robotColors(1:numRobots,:); % Truncate colors in case there are unequal teams
rcolors= env.robotColors;

global flags;
flags=zeros(numRobots,1);

sampleTime = 0.1;              % Sample time [s]
tVec = 0:sampleTime:25;        % Time array                

% Initialize poses randomly, and add bias to each "team"
poses = [10*(rand(2,numRobots) - 0.5); ...
         pi*rand(1,numRobots)];
angleBias = 2*pi*(1:numRobots)/numTeams;
poses(1:2,:) = poses(1:2,:) + 2.5*[sin(angleBias);cos(angleBias)]+20;

%% Simulation loop
vel = zeros(3,numRobots);
for idx = 2:numel(tVec)
    if flags(2) == 1
        % Update the environment
        env(1, poses(:,1));
    else
        % Update the environment
        env(1:numRobots, poses);
    end
    xlim([0 40]);   % Without this, axis resizing can slow things down
    ylim([0 40]); 
    
    % Read the sensor and execute the controller for each robot
    for rIdx = 1:numRobots
       detections = step(detectors{rIdx}); 
       vel(:,rIdx) = swarmTeamController(poses,rIdx,detections,numTeams,env);
    end
    
    % Discrete integration of pose
    poses = poses + vel*sampleTime;

end

%% Helper function: Robot Controller Logic
function vel = swarmTeamController(poses,rIdx,detections,numTeams,env)
    
    % Unpack the robot's pose and team index
    pose = poses(:,rIdx);
    teamIdx = mod(rIdx,numTeams);
    if teamIdx==1
        vel = blueControl(pose,detections,numTeams);
    else
        vel = redControl(pose,rIdx, detections,numTeams,env);
    end
end

function vel = blueControl(pose,detections,numTeams)
    % If there are no detections, turn in place
    v = 0;
    w = 2;
    
    % Else, turn towards the average of detected robots on the same team
    if ~isempty(detections)
    validInds = find(mod(detections(:,3),numTeams) == 0);
        if ~isempty(validInds)
            
            % Take the average range and angle
            range = mean(detections(validInds,1));
            angle = mean(detections(validInds,2));
            
            % Move linearly to maintain a range to the nearest robot
            if range > 0.6
                v = 0.5;
            elseif range < 0.4
                v = -0.5;
            end
            
            % Turn to maintain a heading to the nearest robot
            if angle > pi/12
                w = 2;
            elseif angle < -pi/12
                w = -2;
            end
            
        end
        
    end

    % Convert to global velocity
    vel = bodyToWorld([v;0;w],pose);
end

function vel = redControl(pose,rIdx, detections,numTeams,env)
    % If there are no detections, turn in place
    global flags;
    v = 0;
    w = 2;
    
    % Else, turn towards the average of detected robots on the same team
    if ~isempty(detections)
    validInds = find(mod(detections(:,3),numTeams) == 1);
        if ~isempty(validInds)
            
            % Take the average range and angle
            validVals=detections(validInds,:);
            [range, idx] = min(validVals(:,1));
            angle = validVals(idx,2);
            % Move linearly to maintain a range to the nearest robot
            if flags(rIdx)
                v=0;
            else
                if range<1
                    v=0;
                    flags(rIdx)=1;
                else
                v=-0.1;
                end
            end
           
            
            % Turn to maintain a heading to the nearest robot
            if angle > pi/12
                w = 2;
            elseif angle < -pi/12
                w = -2;
            end
            
        end
        
    end

    % Convert to global velocity
    vel = bodyToWorld([v;0;w],pose);

end


